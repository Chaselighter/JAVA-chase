# Mysql

[[MySQL索引原理及慢查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)](https://tech.meituan.com/2014/06/30/mysql-index.html)



## 定义，优点

- 关系型数据库
- 支持事务
- 提供锁
- 主从复制
- 索引
- 缓存

## innodb物理结构

#### 磁盘io和预读

- 磁盘读取靠的是机械运动，寻道时间，旋转延迟，传输时间，非常高昂的操作
- 计算机系统做了优化，把相邻磁盘的数据也读到内存缓存区中，局部性原理





<img src="/Users/liujianqiang/Documents/数据库/mysql物理结构.jpg" alt="mysql物理结构" style="zoom:50%;" />

### 存储结构

- 表空间，每张表可以有一个文件，也可以多张表在一个文件

- 段

  - 索引段：非叶子节点存储索引
  - 数据段：叶子节点记录数据

- 区

  - 每个页16kb，默认一个区有64页

- 页

  - 页目录中维护多个slot，一个slot包含多条行记录，每个slot2字节，记录里面行记录相对页初始位置的偏移量

  - 索引只能定位到页，而定位到数据页内的行记录还需要进二分查找

  - 二分查找需要借助slot信息，先找到对应的slot，然后在slot内部通过数据行中记录头里的下一个记录地址进行遍历

  - 每一个slot可以包含4-8个数据行。

  - 各个数据页可以组成双向链表，每个页里面的行记录又可以组成单项链表

    - 每个数据页都会为存储在它里面的行记录生成一个页目录，通过主键查找某条记录的时候会在页目录中使用二分查找快速定位到slot，然后遍历slot中的分组
    - 以其他列（非主键）作为搜索条件只能从最小记录开始一次遍历单链表中的每条记录

    <img src="/Users/liujianqiang/Documents/数据库/也目录slot.jpg" alt="也目录slot" style="zoom:50%;" />

    

- 一行记录

  ![行格式](/Users/liujianqiang/Documents/数据库/行格式.jpg)

  - ​	变长字段长度列表，该位置用来存储所声明的变长字段中**非空字段实际占有的长度列表**其中第一个字段长度为3，第二个字段为空，第三个字段长度为1，则将用 01 03 表示，为空字段将在下一个位置进行标记。变长字段长度不能超过 2 个字节，所以 varchar 的长度最大为 2^16=65535。
  - NULL 标志位，占 1 个字节，如果对应的列为空则在对应的位上置为 1 ，否则为 0 ，由于该标志位占一个字节，所以列的数量不能超过 255。如果某字段为空，在后面具体的列数据中将不会在记录。这种方式也导致了在处理索引字段为空的时候需要进行额外的操作。
  - 记录头信息，固定占 5 字节，包含下一条记录的位置，该行记录总长度，记录类型，是否被删除，对应的 slot 信息等
  - 列数据 包含具体的列对应的值，加上两个隐藏列，事务 ID 列和回滚指针列。如果没有申明主键，还会增加一列记录内部 ID。

- Mysql一般为16kb作为一个数据块，操作系统以4kb为一个数据页进行读取。、
- 磁盘io是一个相对很慢的过程，为了提高速度应该尽量减少io读取
- 



## 事务

## 锁

## 索引

### 定义/优点/缺点：

- 一种数据结构，速度快，可排序，加速表和表之间的链接
- 缺点：
  - 维护索引需要耗费时间资源，插入删除修改需要变动索引，表经常update，insert，delete就不要建立索引啦
  - 索引占空间

### 数据结构（高度可控的多路搜索树）

- B+树
  - **为什么要用B+数？**
    - 哈希索引
      - 适合精确查找，不适合范围查找
    - 数组有序查找复杂度o(logn)，插入复杂度o(n),只适合变动小的数据不推荐
    - 哈希
    - 二叉树可能变成链表复杂度o（n）
    - 平衡二叉树数据量变大树的高度太高，io读取耗时，平衡二叉树需要维护节点的删除插入
    - 红黑树操作复杂度高
- 叶子节点存储数据
  - 聚簇索引（存储整行数据）
  - 非聚簇索引（只存储了主键）
- 非叶子节点存储索引
- 一层数据为一页

### 索引失效

- 表达式
  - 因为`MySQL`为该索引维护的B+树就是基于该字段原始数据的，如果正在使用过程中加了函数，`MySQL`就不会认为这个是原来的字段，那肯定不会走索引了。
- 不遵守最左匹配原则
- 涉及到字符类型转换
- 通过索引select*可能不走索引，因为mysql觉得不如全表扫描
- 使用关键字or会使得索引失效，如果不想失效需要为每一个字段都建立索引
- %like和%like%，都不能走索引，%在前不能走索引

### 建立索引原则

- 最左匹配原则
- ==和in可以乱序
- 尽量选择区分度高的列作为索引（distinct/all）
- 索引列不能参加计算
- 尽量拓展索引，不要新建索引
- 经常查询的字段建立索引
- 不为null
- 避免为大字段建索引
- 尽量为order by 和group by后面的字段建立索引

### 慢查询优化步骤

- 先运行下是否真的慢，注意不要设置缓存
- where
- explain，从锁定记录较少的表查起
  - explain关键指标
    - 表的加载顺序，id，id越大优先级越高越先执行，id相同，由上往下执行
      - select_type
        - simple
        - primary
        - Subquery
        - Derived
        - Union
        - Union result
    - type
    - sql查询类型
    - possible_key可能用到的索引，实际用到的索引
    - Key_len
    - Rows
    - 表与表之间的引用关系
    - 一个表中有多少行被优化查询
- 加索引

### 索引为什么快

- 索引将无序的数据变为有序
- 从数据结构开始讲
  - 通过有序查找到页
  - 再从页中定位到

### 索引类型

- 倒排索引
- 唯一索引
- 全文索引

## 主从复制

## 缓存

## 外键

## 分库分表

# Redis

## 定义/优点/缺点

## 主从复制

## Lua脚本

## 单线程模型/IO多路复用

## 数据结构

- string
- hash
- list
- set
- zset

## 持久化

- RDB
- AOF

## 事务

## 集群

## 删除策略

- 定期删除：每隔一段时间删除一批，对内存友好
- 策略删除：去除key进行过期检查，对cpu友好

## 淘汰策略

- volatile-lru
- volatile-ttl
- volatile-random
- Volatile-lfu
- Allkeys-lru
- Allkeys-random
- Allkeys-lfu
- No--eviction

## 应用场景

## 缓存一致性

## 缓存问题





# ES