# java虚拟机

## 1、内存结构

### heap

​	堆是用来存放对象的位置，几乎所有的对象都在堆中；线程共享

### 栈

​	线程独享区域，线程跑的程序的信息，方法/变量。

1. pc计数器

   字节码指令的地址，改变计数来执行字节码指令，程序的流转。如果是native方法，pc计数器的值是未定义的

2. java虚拟机栈

   线程中方法运行都会以栈帧的形式入栈，结束后出栈。

   

   栈帧包含的方法的信息（局部变量，部分计算结果，参与方法的调用和返回），帧可能在heap中分配，所以可能不连续，出现的异常有StackOverflow和OOM。

   - 局部变量表（数组，编译时决定大小，按索引寻址）
     - 八大原始类型（long,double,占用两个slot）
     - 对象的引用
     - returnAddress
   - 操作数栈（程序执行第几行）
   - 动态链接
     - class文件中方法的符号引用，仅仅是一个符号，通过动态链接转为真正的引用。
   - 方法出口信息

3. 本地方法栈

   本地方法的入栈出栈

### 方法区

​	是堆的一个逻辑部分；线程共享；永久代；OOM

- 已经被虚拟机加载的类

- 常量（运行时常量池）

- 数量值

- 字符串值

  String类的intern（）方法可以添加字符

- 类引用（真实地址）

- 字段引用

- 方法引用

- 静态变量

- 即时编译器编译后的代码

*为啥永久代被取消？*

- 内存回收效率低，类的卸载很麻烦；

- 类的信息大小确定都被放到metainfo，不进行垃圾回收；

- 常量池和静态变量还是在堆上因为可以动态扩展；

  *new 字符串的细节*？

  

#### 类的加载过程

1. 加载

   1. 通过类的全限定名获取该类的二进制流

      - “数组类”和非数组类加载比较

        - 非数组可以使用自定义类加载器
        - 数组不是通过类加载器而是通过java虚拟机直接创建，再由类加载器创建数组中的元素类

      - 获取二进制字节流

        - 从zip包中读取，jar，war

        - 从网络中读取。Applet

        - 动态代理

        - JSP文件

        - 从数据库中读取

          

   2. 将二进制字节流所代表的静态结构转为方法区的运行时的数据结构

   3. 在内存中创建一个java.lang.class对象，作为方法区这个类的各种数据访问入口

   4. 注意事项：

      1. 虚拟机规范没有规定class对象的存储位置，虽然是对象却存在方法区中
      2. 加载和链接阶段交叉进行

2. 链接

   1. 验证

      确保class文件中的字节流符合虚拟机规范

      - 文件格式验证
        - 魔术是否为0xCAFEBABE
        - 主次版本号是否在处理范围
        - 常量池是否有不支持的类型
        - 指向常量的索引是否指向不存在
        - utf8型变量是否符合utf8编码
      - 元数据验证，对字节码描述信息进行语义分析，确保其符合java语法规范
      - 字节码验证，对方法体进行语义分析
      - 符号引用阶段

   2. 准备

      1. 为静态变量分配内存并初始化

   3. 解析

      1. 将常量池内的符号引用替换为直接引用

3. 初始化

   1. 类的初始化是类加载的最后一步，是执行类构造器<clinit>()方法的过程
   2. <clinit>()方法是由编译器自动收集类中所有变量的赋值操作和静态代码块中的语句合并而成（编译器收集的顺序是语句在源文件中出现的顺序决定的）
   3. 静态代码块只能访问已经定义的变量、
   4. 父类的<clinit>()方法在子类之前执行，所以父类的静态方法也是先执行
   5. 虚拟机会对<clinit>()方法加锁，只有一个线程可以访问。

#### 类文件结构

1. class文件结构

#### 类加载的时机

1. 类的生命周期
2. 类加载过程中的初始化开始的时机
   1. 遇到new，putstatic，getstatic，invokestatic字节码指令时，如果类没有初始化，则需要先触发其初始化
   2. 对类进行反射调用时，如果类还没有初始化，就会触发
   3. 初始化一个类时，如果父类没有初始化
   4. 虚拟机启动时需要初始化一个含有main()方法的主类
   5. ~~当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为  REF_getStatic、REF_putStatic、REF_invokeStatic  的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化。~~
   6. 这五种场景的行为称为对一个类进行主动y引用，除此之外，其他所有引用类的方式都不会触发初始化，称为被动引用
3. 被动引用
   1. 子类引用父类的静态字段，只会触发父类的初始化
   2. 数组初始化的时候里面的类不会优先初始化，通过数组定义来引用类，不会触发此类的初始化
   3. 常量在编译阶段会存入调用类中的常量池，本质上并没有直接引用到定义常量的类，不会触发初始化

#### 类加载器

- 种类：
  - 启动类加载器
  - 拓展类加载器
  - 应用程序类加载器

- 为什么使用双亲委派加载模型
- 双亲委派加载模型：
  - 描述类加载器之间的层次关系。他要求类加载器都有自己的父类，除了启动类加载器
  - 如果一个类加载器收到了类加载的请求，他不会自己去尝试这个类，而是把这个请求委派给父类加载，只有当父类无法加载时才自己加载。
  - 自底向上检查是否加载，加载了就直接放回，直到启动类加载器；如果还没有加载过，就开始自上而下委派
  - 确定一个类是否相等，是由类加载器和类决定的，像java.lang.Object这些存放rt.jar中的类，无论使用哪个类加载器加载都会委派给最顶端的启动类加载器加载，从而使得Object类都是同一个。



